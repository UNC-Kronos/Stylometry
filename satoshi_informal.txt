A purely peer-to-peer version of electronic cash would allow online payments to be sent directly from one party to another without going through a financial institution. Digital signatures provide part of the solution, but the main benefits are lost if a trusted third party is still required to prevent double-spending. We propose a solution to the double-spending problem using a peer-to-peer network. The network timestamps transactions by hashing them into an ongoing chain of hash-based proof-of-work, forming a record that cannot be changed without redoing the proof-of-work. The longest chain not only serves as proof of the sequence of events witnessed, but proof that it came from the largest pool of CPU power. As long as a majority of CPU power is controlled by nodes that are not cooperating to attack the network, they’ll generate the longest chain and outpace attackers. The network itself requires minimal structure. Messages are broadcast on a best effort basis, and nodes can leave and rejoin the network at will, accepting the longest proof-of-work chain as proof of what happened while they were gone. 

Commerce on the Internet has come to rely almost exclusively on financial institutions serving as trusted third parties to process electronic payments. While the system works well enough for most transactions, it still suffers from the inherent weaknesses of the trust based model. Completely non-reversible transactions are not really possible, since financial institutions cannot avoid mediating disputes. The cost of mediation increases transaction costs, limiting the minimum practical transaction size and cutting off the possibility for small casual transactions, and there is a broader cost in the loss of ability to make non-reversible payments for non-reversible services. With the possibility of reversal, the need for trust spreads. Merchants must be wary of their customers, hassling them for more information than they would otherwise need. A certain percentage of fraud is accepted as unavoidable. These costs and payment uncertainties can be avoided in person by using physical currency, but no mechanism exists to make payments over a communications channel without a trusted party. 

What is needed is an electronic payment system based on cryptographic proof instead of trust, allowing any two willing parties to transact directly with each other without the need for a trusted third party. Transactions that are computationally impractical to reverse would protect sellers from fraud, and routine escrow mechanisms could easily be implemented to protect buyers. In this paper, we propose a solution to the double-spending problem using a peer-to-peer distributed timestamp server to generate computational proof of the chronological order of transactions. The system is secure as long as honest nodes collectively control more CPU power than any cooperating group of attacker nodes. 

We define an electronic coin as a chain of digital signatures. Each owner transfers the coin to the next by digitally signing a hash of the previous transaction and the public key of the next owner and adding these to the end of the coin. A payee can verify the signatures to verify the chain of ownership. 

The problem of course is the payee can’t verify that one of the owners did not double-spend the coin. A common solution is to introduce a trusted central authority, or mint, that checks every transaction for double spending. After each transaction, the coin must be returned to the mint to issue a new coin, and only coins issued directly from the mint are trusted not to be double-spent. The problem with this solution is that the fate of the entire money system depends on the company running the mint, with every transaction having to go through them, just like a bank. 

We need a way for the payee to know that the previous owners did not sign any earlier transactions. For our purposes, the earliest transaction is the one that counts, so we don’t care about later attempts to double-spend. The only way to confirm the absence of a transaction is to be aware of all transactions. In the mint based model, the mint was aware of all transactions and decided which arrived first. To accomplish this without a trusted party, transactions must be publicly announced[1], and we need a system for participants to agree on a single history of the order in which they were received. The payee needs proof that at the time of each transaction, the majority of nodes agreed it was the first received. 

The solution we propose begins with a timestamp server. A timestamp server works by taking a hash of a block of items to be timestamped and widely publishing the hash, such as in a newspaper or Usenet post[2-5]. The timestamp proves that the data must have existed at the time, obviously, in order to get into the hash. Each timestamp includes the previous timestamp in its hash, forming a chain, with each additional timestamp reinforcing the ones before it. 

To implement a distributed timestamp server on a peer-to-peer basis, we will need to use a proof-of-work system similar to Adam Back’s Hashcash[6], rather than newspaper or Usenet posts. The proof-of-work involves scanning for a value that when hashed, such as with SHA-256, the hash begins with a number of zero bits. The average work required is exponential in the number of zero bits required and can be verified by executing a single hash. 

For our timestamp network, we implement the proof-of-work by incrementing a nonce in the block until a value is found that gives the block’s hash the required zero bits. Once the CPU effort has been expended to make it satisfy the proof-of-work, the block cannot be changed without redoing the work. As later blocks are chained after it, the work to change the block would include redoing all the blocks after it. 

The proof-of-work also solves the problem of determining representation in majority decision making. If the majority were based on one-IP-address-one-vote, it could be subverted by anyone able to allocate many IPs. Proof-of-work is essentially one-CPU-one-vote. The majority decision is represented by the longest chain, which has the greatest proof-of-work effort invested in it. If a majority of CPU power is controlled by honest nodes, the honest chain will grow the fastest and outpace any competing chains. To modify a past block, an attacker would have to redo the proof-of-work of the block and all blocks after it and then catch up with and surpass the work of the honest nodes. We will show later that the probability of a slower attacker catching up diminishes exponentially as subsequent blocks are added. 

To compensate for increasing hardware speed and varying interest in running nodes over time, the proof-of-work difficulty is determined by a moving average targeting an average number of blocks per hour. If they’re generated too fast, the difficulty increases. 

The steps to run the network are as follows: 

New transactions are broadcast to all nodes. 

Each node collects new transactions into a block. 

Each node works on finding a difficult proof-of-work for its block. 

When a node finds a proof-of-work, it broadcasts the block to all nodes. 

Nodes accept the block only if all transactions in it are valid and not already spent. 

Nodes express their acceptance of the block by working on creating the next block in the chain, using the hash of the accepted block as the previous hash. 

Nodes always consider the longest chain to be the correct one and will keep working on extending it. If two nodes broadcast different versions of the next block simultaneously, some nodes may receive one or the other first. In that case, they work on the first one they received, but save the other branch in case it becomes longer. The tie will be broken when the next proof-of-work is found and one branch becomes longer; the nodes that were working on the other branch will then switch to the longer one. 

New transaction broadcasts do not necessarily need to reach all nodes. As long as they reach many nodes, they will get into a block before long. Block broadcasts are also tolerant of dropped messages. If a node does not receive a block, it will request it when it receives the next block and realizes it missed one. 

By convention, the first transaction in a block is a special transaction that starts a new coin owned by the creator of the block. This adds an incentive for nodes to support the network, and provides a way to initially distribute coins into circulation, since there is no central authority to issue them. The steady addition of a constant of amount of new coins is analogous to gold miners expending resources to add gold to circulation. In our case, it is CPU time and electricity that is expended. 

The incentive can also be funded with transaction fees. If the output value of a transaction is less than its input value, the difference is a transaction fee that is added to the incentive value of the block containing the transaction. Once a predetermined number of coins have entered circulation, the incentive can transition entirely to transaction fees and be completely inflation free. 

The incentive may help encourage nodes to stay honest. If a greedy attacker is able to assemble more CPU power than all the honest nodes, he would have to choose between using it to defraud people by stealing back his payments, or using it to generate new coins. He ought to find it more profitable to play by the rules, such rules that favour him with more new coins than everyone else combined, than to undermine the system and the validity of his own wealth. 

Once the latest transaction in a coin is buried under enough blocks, the spent transactions before it can be discarded to save disk space. To facilitate this without breaking the block’s hash, transactions are hashed in a Merkle Tree [7][2][5], with only the root included in the block’s hash. Old blocks can then be compacted by stubbing off branches of the tree. The interior hashes do not need to be stored. 

Transactions Hashed in a Merkle Tree 
After Pruning Tx0-2 from the Block 

A block header with no transactions would be about 80 bytes. If we suppose blocks are generated every 10 minutes, 80 bytes * 6 * 24 * 365 = 4.2MB per year. With computer systems typically selling with 2GB of RAM as of 2008, and Moore’s Law predicting current growth of 1.2GB per year, storage should not be a problem even if the block headers must be kept in memory. 

It is possible to verify payments without running a full network node. A user only needs to keep a copy of the block headers of the longest proof-of-work chain, which he can get by querying network nodes until he’s convinced he has the longest chain, and obtain the Merkle branch linking the transaction to the block it’s timestamped in. He can’t check the transaction for himself, but by linking it to a place in the chain, he can see that a network node has accepted it, and blocks added after it further confirm the network has accepted it. 

As such, the verification is reliable as long as honest nodes control the network, but is more vulnerable if the network is overpowered by an attacker. While network nodes can verify transactions for themselves, the simplified method can be fooled by an attacker’s fabricated transactions for as long as the attacker can continue to overpower the network. One strategy to protect against this would be to accept alerts from network nodes when they detect an invalid block, prompting the user’s software to download the full block and alerted transactions to confirm the inconsistency. Businesses that receive frequent payments will probably still want to run their own nodes for more independent security and quicker verification. 

Although it would be possible to handle coins individually, it would be unwieldy to make a separate transaction for every cent in a transfer. To allow value to be split and combined, transactions contain multiple inputs and outputs. Normally there will be either a single input from a larger previous transaction or multiple inputs combining smaller amounts, and at most two outputs: one for the payment, and one returning the change, if any, back to the sender. 

It should be noted that fan-out, where a transaction depends on several transactions, and those transactions depend on many more, is not a problem here. There is never the need to extract a complete standalone copy of a transaction’s history. 

The traditional banking model achieves a level of privacy by limiting access to information to the parties involved and the trusted third party. The necessity to announce all transactions publicly precludes this method, but privacy can still be maintained by breaking the flow of information in another place: by keeping public keys anonymous. The public can see that someone is sending an amount to someone else, but without information linking the transaction to anyone. This is similar to the level of information released by stock exchanges, where the time and size of individual trades, the “tape”, is made public, but without telling who the parties were. 

As an additional firewall, a new key pair should be used for each transaction to keep them from being linked to a common owner. Some linking is still unavoidable with multi-input transactions, which necessarily reveal that their inputs were owned by the same owner. The risk is that if the owner of a key is revealed, linking could reveal other transactions that belonged to the same owner. 

We consider the scenario of an attacker trying to generate an alternate chain faster than the honest chain. Even if this is accomplished, it does not throw the system open to arbitrary changes, such as creating value out of thin air or taking money that never belonged to the attacker. Nodes are not going to accept an invalid transaction as payment, and honest nodes will never accept a block containing them. An attacker can only try to change one of his own transactions to take back money he recently spent. 

The race between the honest chain and an attacker chain can be characterized as a Binomial Random Walk. The success event is the honest chain being extended by one block, increasing its lead by +1, and the failure event is the attacker’s chain being extended by one block, reducing the gap by -1. 

The probability of an attacker catching up from a given deficit is analogous to a Gambler’s Ruin problem. Suppose a gambler with unlimited credit starts at a deficit and plays potentially an infinite number of trials to try to reach breakeven. We can calculate the probability he ever reaches breakeven, or that an attacker ever catches up with the honest chain, as follows: 

Given our assumption that p>q, the probability drops exponentially as the number of blocks the attacker has to catch up with increases. With the odds against him, if he doesn’t make a lucky lunge forward early on, his chances become vanishingly small as he falls further behind. 

We now consider how long the recipient of a new transaction needs to wait before being sufficiently certain the sender can’t change the transaction. We assume the sender is an attacker who wants to make the recipient believe he paid him for a while, then switch it to pay back to himself after some time has passed. The receiver will be alerted when that happens, but the sender hopes it will be too late. 

The receiver generates a new key pair and gives the public key to the sender shortly before signing. This prevents the sender from preparing a chain of blocks ahead of time by working on it continuously until he is lucky enough to get far enough ahead, then executing the transaction at that moment. Once the transaction is sent, the dishonest sender starts working in secret on a parallel chain containing an alternate version of his transaction. 

The recipient waits until the transaction has been added to a block and  blocks have been linked after it. He doesn’t know the exact amount of progress the attacker has made, but assuming the honest blocks took the average expected time per block, the attacker’s potential progress will be a Poisson distribution with expected value: 

To get the probability the attacker could still catch up now, we multiply the Poisson density for each amount of progress he could have made by the probability he could catch up from that point: 

Rearranging to avoid summing the infinite tail of the distribution… 

Converting to C code… 

Running some results, we can see the probability drop off exponentially with z. 

Solving for P less than 0.1%… 

We have proposed a system for electronic transactions without relying on trust. We started with the usual framework of coins made from digital signatures, which provides strong control of ownership, but is incomplete without a way to prevent double-spending. To solve this, we proposed a peer-to-peer network using proof-of-work to record a public history of transactions that quickly becomes computationally impractical for an attacker to change if honest nodes control a majority of CPU power. The network is robust in its unstructured simplicity. Nodes work all at once with little coordination. They do not need to be identified, since messages are not routed to any particular place and only need to be delivered on a best effort basis. Nodes can leave and rejoin the network at will, accepting the proof-of-work chain as proof of what happened while they were gone. They vote with their CPU power, expressing their acceptance of valid blocks by working on extending them and rejecting invalid blocks by refusing to work on them. Any needed rules and incentives can be enforced with this consensus mechanism. 

I've developed a new open source P2P e-cash system called Bitcoin. It's completely decentralized, with no central server or trusted parties, because everything is based on crypto proof instead of trust. Give it a try, or take a look at the screenshots and design paper: 
 
Download Bitcoin v0.1 at http://www.bitcoin.org 
 
The root problem with conventional currency is all the trust that's required to make it work. The central bank must be trusted not to debase the currency, but the history of fiat currencies is full of breaches of that trust. Banks must be trusted to hold our money and transfer it electronically, but they lend it out in waves of credit bubbles with barely a fraction in reserve. We have to trust them with our privacy, trust them not to let identity thieves drain our accounts. Their massive overhead costs make micropayments impossible. 
 
A generation ago, multi-user time-sharing computer systems had a similar problem. Before strong encryption, users had to rely on password protection to secure their files, placing trust in the system administrator to keep their information private. Privacy could always be overridden by the admin based on his judgment call weighing the principle of privacy against other concerns, or at the behest of his superiors. Then strong encryption became available to the masses, and trust was no longer required. Data could be secured in a way that was physically impossible for others to access, no matter for what reason, no matter how good the excuse, no matter what. 
 
It's time we had the same thing for money. With e-currency based on cryptographic proof, without the need to trust a third party middleman, money can be secure and transactions effortless. 
 
One of the fundamental building blocks for such a system is digital signatures. A digital coin contains the public key of its owner. To transfer it, the owner signs the coin together with the public key of the next owner. Anyone can check the signatures to verify the chain of ownership. It works well to secure ownership, but leaves one big problem unsolved: double-spending. Any owner could try to re-spend an already spent coin by signing it again to another owner. The usual solution is for a trusted company with a central database to check for double-spending, but that just gets back to the trust model. In its central position, the company can override the users, and the fees needed to support the company make micropayments impractical. 
 
Bitcoin's solution is to use a peer-to-peer network to check for double-spending. In a nutshell, the network works like a distributed timestamp server, stamping the first transaction to spend a coin. It takes advantage of the nature of information being easy to spread but hard to stifle. For details on how it works, see the design paper at http://www.bitcoin.org/bitcoin.pdf 
 
The result is a distributed system with no single point of failure. Users hold the crypto keys to their own money and transact directly with each other, with the help of the P2P network to check for double-spending. 
 
Satoshi Nakamoto 
http://www.bitcoin.org 

Could be. They're talking about the old Chaumian central mint stuff, but maybe only because that was the only thing available. Maybe they would be interested in going in a new direction. 
 
A lot of people automatically dismiss e-currency as a lost cause because of all the companies that failed since the 1990's. I hope it's obvious it was only the centrally controlled nature of those systems that doomed them. I think this is the first time we're trying a decentralized, non-trust-based system. 

It is a global distributed database, with additions to the database by consent of the majority, based on a set of rules they follow: 
 
- Whenever someone finds proof-of-work to generate a block, they get some new coins 
- The proof-of-work difficulty is adjusted every two weeks to target an average of 6 blocks per hour (for the whole network) 
- The coins given per block is cut in half every 4 years 
 
You could say coins are issued by the majority. They are issued in a limited, predetermined amount. 
 
As an example, if there are 1000 nodes, and 6 get coins each hour, it would likely take a week before you get anything. 
 
To Sepp's question, indeed there is nobody to act as central bank or federal reserve to adjust the money supply as the population of users grows. That would have required a trusted party to determine the value, because I don't know a way for software to know the real world value of things. If there was some clever way, or if we wanted to trust someone to actively manage the money supply to peg it to something, the rules could have been programmed for that. 
 
In this sense, it's more typical of a precious metal. Instead of the supply changing to keep the value the same, the supply is predetermined and the value changes. As the number of users grows, the value per coin increases. It has the potential for a positive feedback loop; as users increase, the value goes up, which could attract more users to take advantage of the increasing value. 

I am not Dorian Nakamoto. 

Welcome to the new Bitcoin forum! 
 
The old forum can still be reached here: 
http://bitcoin.sourceforge.net/boards/index.php 
 
I'll repost some selected threads here and add updated answers to questions where I can. 
 
FAQ 
http://bitcoin.sourceforge.net/wiki/index.php?page=FAQ 
 
Download 
http://sourceforge.net/projects/bitcoin/files/ 

From the user's perspective the bitcoin maturation process can be broken down into 8 stages. 
 
1. The initial network transaction that occurs when you first click Generate Coins. 
2. The time between that initial network transaction and when the bitcoin entry is ready to appear in the All Transactions list. 
3. The change of the bitcoin entry from outside the All Transaction field to inside it. 
4. The time between when the bitcoin appears in the All Transfers list and when the Description is ready to change to Generated (50.00 matures in x more blocks). 
5. The change of the Description to Generated (50.00 matures in x more blocks). 
6. The time between when the Description says Generated (50.00 matures in x more blocks) to when it is ready to change to Generated. 
7 The change of the Description to Generated. 
8. The time after the Description has changed to Generated. 
 
Which stages require network connectivity, significant local CPU usage and or significant remote CPU usage? Do any of these stages have names? 

As far as I know, there's no network transaction when you click Generate Coins - your computer just starts calculating the next proof-of-work.  The CPU usage is 100% when you're generating coins. 
 
In this example, the network connection is used when you broadcast the information about the proof-of-work block you've created (that which entitles you to the new coin). Generating coins successfully requires constant connectivity, so that you can start working on the next block when someone gets the current block before you. 

It's important to have network connectivity while you're trying to generate a coin (block) and at the moment it is successfully generated. 
 
1) During generation (when the status bar says "Generating" and you're using CPU to find a proof-of-work), you must constantly keep in contact with the network to receive the latest block. If your block does not link to the latest block, it may not be accepted. 
 
2) When you successfully generate a block, it is immediately broadcast to the network.  Other nodes must receive it and link to it for it to be accepted as the new latest block. 
 
Think of it as a cooperative effort to make a chain.  When you add a link, you must first find the current end of the chain.  If you were to locate the last link, then go off for an hour and forge your link, come back and link it to the link that was the end an hour ago, others may have added several links since then and they're not going to want to use your link that now branches off the middle. 
 
After a block is created, the maturation time of 120 blocks is to make absolutely sure the block is part of the main chain before it can be spent.  Your node isn't doing anything with the block during that time, just waiting for other blocks to be added after yours.  You don't have to be online during that time. 

There will be a proxy setting in version 0.2 so you can connect through TOR.  I've done a careful scrub to make sure it doesn't use DNS or do anything that would leak your IP while in proxy mode. 

Bitcoins are sent to and from bitcoin addresses, which are essentially random numbers with no identifying information. 
 
When you send to an IP address, the transaction is still written to a bitcoin address.  The IP address is only used to connect to the recipient's computer to request a fresh bitcoin address, give the transaction directly to the recipient and get a confirmation.  
 
Blocks contain a history of the bitcoin addresses that a coin has been transferred to.  If the identities of the people using the bitcoin addresses are not known and each address is used only once, then this information only reveals that some unknown person transferred some amount to someone else. 
 
The possibility to be anonymous or pseudonymous relies on you not revealing any identifying information about yourself in connection with the bitcoin addresses you use.  If you post your bitcoin address on the web, then you're associating that address and any transactions with it with the name you posted under.  If you posted under a handle that you haven't associated with your real identity, then you're still pseudonymous. 
 
For greater privacy, it's best to use bitcoin addresses only once.  You can change addresses as often as you want using Options->Change Your Address.  Transfers by IP address automatically use a new bitcoin address each time. 

No. 

In the next release (version 0.2), the command line to run it through a proxy from the first time is: 
bitcoin -proxy=127.0.0.1:9050 
 
The problem for TOR is that the IRC server which Bitcoin uses to initially discover other nodes bans the TOR exit nodes, as all IRC servers do.  If you've already connected once before then you're already seeded, but for the first time, you'd need to provide the address of a node as such: 
bitcoin -proxy=127.0.0.1:9050 -addnode=<someipaddress> 
 
If someone running a node with a static IP address that can accept incoming connections could post their IP to use for -addnode, that would be great. 

Whichever one you've set your NAT to forward port 8333 to will receive it.  If your router can change the port number when it forwards, you could allow more than one client to receive.  For instance, if port 8334 forwards to a computer's port 8333, then senders could send to "x.x.x.x:8334"  
 
If your NAT can't translate port numbers, there currently isn't a command line option to change the incoming port that bitcoin binds to, but I'll look into it. 

The Linux version is on its way.  Martti's Linux port was merged into the main code branch and New Liberty Standard has been testing it.  It'll be in the next release, version 0.2. 
 
Command line is on the to-do list after 0.2. 

We've been working hard on improvements for the next version release.  Martti (sirius-m) added some nice features to make it more user friendly and easier to run in the background: 
 - Minimize to system tray option 
 - Autostart on boot option so you can keep it running in the background automatically 
 - New options dialog layout 
 - Setup EXE for Windows, in addition to the archive download 
 
I've been working on a number of refinements to the networking code and laying the groundwork for future functionality.  Also coming in version 0.2: 
 - Multi-processor support for coin generation 
 - Proxy support 

Helpful suggestions, thanks. 

That's a good idea.  The side accepting the connection just needs to withhold from sending anything until it receives a valid handshake.  Any portscan would only get a dead connection that doesn't volunteer to identify itself. 

I have thought about eventually SSLing all the connections.  I assume anything short of SSL would be pointless against DPI.  Maybe a better more immediate solution is to connect through TOR, which will be possible with 0.2.   

That's one of the main things on the agenda after 0.2. 

Yeah, the other stealth stuff would be kinda pointless if it's always the same port number. 

I'm looking forward to trying UPnP.  Do most P2P clients typically have UPnP enabled by default? 

I'm still thinking about how best to structure the management interface.  Maybe command line commands to communicate with the background daemon to query transactions received and initiate sending transfers.  That would be more automation friendly.  Or what about an http interface on some port other than 80 to manage it with a browser? 

That's a good approach for mobile.  Programmatic API used by PHP (any language) to present a web UI covers remote admin, mobile and any other client that can't be online all the time with a static IP.  It would be like webmail.  It would be easier for new users to get started if they only need to create an account on a website, not install software. 

Yeah, we can phase out IRC when there are enough static nodes to preprogram a seed list.  Once you get seeded, you don't need IRC. 

There were some issues in 0.1.5 where the initial block download could get bogged down.  0.2 has code to make sure it goes smoothly.  It ought to take less than an hour, I think.  I need to hurry up and get 0.2 out the door. 
 
The blocks increase linearly, it'll be decades before it's millions.  In theory, the block download time should top out 8 months from now when Moore's Law will be growing faster than the block chain. 

It's SVN on sourceforge.  PM or e-mail me your sourceforge account and I'll give you access. 

That's great because that's where I have less expertise.  For instance, I haven't researched the best way to do the "Start Bitcoin on system startup" feature on Linux.  On Windows, the option adds/removes an icon in the Startup folder. 

1-3: 
For that level of anonymity you need to connect through TOR, which will be possible with version 0.2, which is only a few weeks away.  I'll post TOR instructions at that time. 
 
4: 
Version 0.1.5: backup the whole %appdata%\Bitcoin directory. 
Version 0.2: you can backup just wallet.dat. 
 
5: 
Nope.  The whole design is all about preventing that from working. 
 
6: 
Those coins can never be recovered, and the total circulation is less.  Since the effective circulation is reduced, all the remaining coins are worth slightly more.  It's the opposite of when a government prints money and the value of existing money goes down. 
 
7: 
It's currently 29,296 blocks.  The circulation is the number of blocks times 50, so the current circulation is 1,464,800 bc.   
 
If you only have 24k blocks, it must not have finished the initial block download.  Exit bitcoin and start it again.  Version 0.2 is better/faster at the initial block download. 
 
8: 
Typically a few hundred right now.  It's easy now but it'll get harder as the network grows. 
 
9: 
Good question, it's TCP.  The website needs to be updated to say TCP port 8333. 
 
The port forwarding is so other nodes can connect to you, so it helps you stay connected because you are able to be connected with more nodes.  You also need it to receive payments by IP address. 
 
10: 
No, the other nodes won't accept that. 
 
Being open source means anyone can independently review the code.  If it was closed source, nobody could verify the security.  I think it's essential for a program of this nature to be open source. 
 
11: 
Slower machines produce fewer coins.  It's proportional to CPU speed. 
 
12: 
There are more coming. 
 
13: 
It uses a transactional database called Berkeley DB.  It will not lose data in a system crash.  Transactions are written to the database immediately when they're received. 
 
14: 
For now, you can just multiply the total blocks by 50.  The Bitcoin network has been running for almost a year now.  The design and coding started in 2007. 

That's true, with the send-to-IP option, you are sending to whoever answers that IP.  Sending to a bitcoin address doesn't have that problem. 
 
The plan is to implement an IP + bitcoin address option that would have the benefits of both.  It would still use a different address for each transaction, but the receiver would sign the one-time-use address with the given bitcoin address to prove it belongs to the intended receiver. 

Right, the SVN has the almost-release-candidate 0.2 source, which can also be built and run on Linux.   It hasn't been tested on FreeBSD. 

That would be a big help.  TOR users wouldn't have to worry about how to get seeded, and we wouldn't depend on IRC. 
 
It can be run in a few simple modes without access to the UI if you don't mind a minimized window on the desktop.  (0.1.5 doesn't have -min so it would be an open window) 
 
To only run a seed: 
bitcoin -min -gen=0 
 
You could sort of monitor it by looking at debug.log.  To stop it, kill the process, the database won't mind. 
 
To generate: 
bitcoin -min -gen 
 
To get the generated bitcoins, you'd have to copy wallet.dat (with version 0.2) to a machine with a UI, swap in the wallet.dat, run bitcoin and transfer the coins to your main account.  (With version 0.1.5 you'd have to copy the whole "%appdata%/Bitcoin" directory.)  There is one caveat about copying wallet.dat: if you happened to kill the program at the exact moment that it generated a coin or received a payment, wallet.dat might not work by itself and you'd have to copy the whole directory. 

I see, that would happen with multiple nodes using the same NAT or VPN or some ISP that funnels everyone through a few proxy servers.  I just committed a fix to SVN for this.  If it gets "433" name already in use (it was error 433, right?), it'll retry with a non-address random username.   

That's great, any help is really appreciated! 

The average total coins generated across the network per day stays the same.  Faster machines just get a larger share than slower machines.  If everyone bought faster machines, they wouldn't get more coins than before. 
 
We should have a gentleman's agreement to postpone the GPU arms race as long as we can for the good of the network.  It's much easer to get new users up to speed if they don't have to worry about GPU drivers and compatibility.  It's nice how anyone with just a CPU can compete fairly equally right now. 

Mac support would be nice.  wxWidgets really pays off for cross platform. 
 
Please don't try PPC.  PPC is big-endian and Bitcoin is little-endian, there would be endless endian bugs making it harder for me to debug the network if there's a potentially byte-swapping node out there.  PPC is on its way out anyway. 
 
Considered autoconf.  Autoconf is a necessity for large projects with a quagmire makefile, but I think we're small enough that it's more optimal without it.  I'd rather keep the makefile simple as long as possible. 

My head hurts just thinking about that.  Funnelling all the UI backend through a TCP connection would make everything twice as hard.  There's too much bandwidth between the UI and the internal data structures in order to keep the listview control updated, because of the way the listview control works. 
 
I'd rather have command line control, that would get us remote admin and batch automation. 

There would be a command line switch at runtime to tell it to run without UI.  All it needs to do is not create the main window.  A simplistic way would be to disable "pframeMain->Show" and "ptaskbaricon->Show" in ui.cpp.  The network threads don't care that the UI isn't there.  The only other UI is a message box in CheckDiskSpace if it runs out of disk space. 
 
Then a separate command line utility to communicate with it to do things.  Not sure what it should be named. 
 
"natural deflation"... I like that name for it.  Yes, there will be natural deflation due to payment mistakes and lost data.  Coin creation will eventually get slow enough that it is exceeded by natural deflation and we'll have net deflation. 

It looks like the implicit conversion from std::string to wxString isn't working.  That's used everywhere, the conversion needs to work. 
 
wxString is complicated by supporting win32's 16-bit wchar and 8-bit ansi dual-compile.  You can get that problem on Windows if the "unicode" (meaning wchar) build is used, so that wxString is wchar and std::string is char. 
 
It's probably some wxWidgets compile defines or build configuration.  What "configure" options did you use? 
 
I'm not sure __WXMAC__ is the right define.  It may be the Mac Classic support that's complicating wxString, and we only want OSX.  Try __WXOSX__ (or see below) 
 
http://docs.wxwidgets.org/stable/wx_cppconst.html 
"There are two wxWidgets ports to Mac OS. One of them, wxMac, exists in two versions: Classic and Carbon. The Classic version is the only one to work on Mac OS version 8. The Carbon version may be built either as CFM or Mach-O (binary format, like ELF) and the former may run under OS 9 while the latter only runs under OS X. Finally, there is a new Cocoa port which can only be used under OS X. To summarize: 
 
    * If you want to test for all Mac platforms, classic and OS X, you should test both __WXMAC__ and __WXCOCOA__. 
    * If you want to test for any GUI Mac port under OS X, use __WXOSX__. 
    * If you want to test for any port under Mac OS X, including, for example, wxGTK and also wxBase, use __DARWIN__" 

Then it must be something you're doing differently with building or configuring wxWidgets. 
 
What options did you use on the wxWidgets "configure" script?  The options I used are in build-unix.txt. 

Never heard of that happening.  Is there anything in debug.log?  If you touched the file, that sounds like something is there.  Does the program have write access to the file? 

Bitcoin version 0.2 is here! 
 
Download links: 
http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.2.0-win32-setup.exe/download 
http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.2.0-win32.zip/download 
http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.2.0-linux.tar.gz/download 
 
New Features 
 
Martti Malmi 
 - Minimize to system tray option 
 - Autostart on boot option so you can keep it running in the background automatically 
 - New options dialog layout for future expansion 
 - Setup program for Windows 
 - Linux version (tested on Ubuntu) 
Satoshi Nakamoto 
 - Multi-processor support for coin generation 
 - Proxy support for use with TOR 
 - Fixed some slowdowns in the initial block download 
 
Major thanks to Martti Malmi (sirius-m) for all his coding work and for hosting the new site and this forum, and New Liberty Standard for his help with testing the Linux version. 

That's good, is it running fine on FreeBSD? 
 
I committed the changes to headers.h.  For consistency, I used __BSD__.  The complete list of defines is at http://docs.wxwidgets.org/stable/wx_cppconst.html 
#ifdef __BSD__ 
#include <netinet/in.h> 
#endif 
 
malloc.h is only needed on windows, I'll move that into the __WXMSW__ section before it causes any more trouble. 

What you can currently do is set "Minimize to the tray" in options, then run it as "bitcoin -min" so it starts minimized.  The only visible part will be a small (20x20) icon on the tray, which can be doubleclicked if you want to access the UI.  Note: there's a bug with tray icons sometimes disappearing on 64-bit Karmic Koala, not sure if it's from 64-bit or Karmic, it was fine on 32-bit Jaunty. 
 
We didn't have time to implement the "Start Bitcoin on system startup" feature on Linux in time for 0.2 so it's greyed out.  I figured Linux people wouldn't mind doing that manually anyway.  I guess they need to know about the -min switch to do it right. 
 
You can locate the data directory where you want with the "-datadir=<directory>" switch.  I know someone is already doing that to put it on a TrueCrypt USB drive. 

The transfer is immediate if you send by IP address.  If you send by bitcoin address and the recipient isn't online at the time, it might take 30 minutes or more to see it.   
 
Also, the recipient needs to be synced up with the block chain before it'll see the received transaction.  That means the status bar at the bottom needs to say at least 33000 blocks, like "x connections  33200 blocks  x transactions". 

Would it be clearer if the status said "x confirmations", like: 
2/unconfirmed 
3/unconfirmed 
4/unconfirmed 
5/unconfirmed 
6 confirmations 
7 confirmations 
8 confirmations 
 
Each block essentially means another node has confirmed that it agrees with all transactions up to that point. 

I haven't tried compiling 64-bit yet. 64-bit wouldn't make it any faster, since it uses 64-bit numbers in only a few places and SHA-256 is a 32-bit algorithm, but it may be convenient for those running a 64-bit OS. If I get a chance I'll try -m64 and see what the problem is. 
 
You can run the 32-bit version on 64-bit Linux by installing ia32-libs.  (sudo apt-get install ia32-libs)  If we made a Debian package, it could automatically pull that in as a dependency. 

Coins generate at the same speed with any number of connections >= 1. 
 
More connections just add redundancy.  If you only had one connection, what if that node is slow or busy, or only connected to you?  Having several connections increases the certainty that you're well connected to the network.  That hasn't been a problem in practice, the network is very thoroughly connected.  If you have 2 or 3 connections, you're fine. 

I've been thinking about that for a while.  I want to add the backend support for .onion addresses and connecting to them, then go from there. 
 
There aren't many .onion addresses in use for anything because the user has to go through a number of steps to create one.  Configure TOR to generate a .onion address, restart TOR, configure it with the generated address.  Perhaps this is intentional to keep TOR so it can't be integrated into file sharing programs in any sufficiently automated way. 

That is what happens if you copy wallet files around.  If you copy your wallet file to a second computer, then they both think the money in the wallet is theirs.  If one spends any of it, the other doesn't know those coins are already spent and would try to spend them again, and that's the error you would hit. 
 
Now that it's clear this is a key error message, it ought to be something more like "the money appears to be already spent...  this could happen if you used a copy of your wallet file on another computer."  
 
You can move or backup your wallet file, but it needs to have only one "lineage" and only used in one place at a time.  Any time you transfer money out of it, then you must no longer use any previous copies. 
 
This brings up a good point.  In the case of restoring a backup that may be from before you spent some coins, we need to add functionality to resync it to discover which coins have already been spent.  This would not be hard to do, it just hasn't been implemented yet.  I'll add it to the list.  This would make it mostly repair the situation instead of giving that error message. 

Yes, it's a technical limitation.  Sending by bitcoin address enters the transaction into the network and the recipient discovers it from the network.  You don't connect directly with them and they don't have to be online at the time. 
 
I very much wanted to find some way to include a short message, but the problem is, the whole world would be able to see the message.  As much as you may keep reminding people that the message is completely non-private, it would be an accident waiting to happen. 
 
Unfortunately, ECDSA can only sign signatures, it can't encrypt messages, and we need the small size of ECDSA.  RSA can encrypt messages, but it's many times bigger than ECDSA. 

Where it says "# blocks" in the status column I'm changing it to say "# confirmations".  That might be clearer. 
 
If you doubleclick on the transaction you get a little more information. 

The resync idea would go through your wallet and check it against the block index to find any transactions that your current computer doesn't realize are already spent.  That could happen if they were spent on another computer with a copy of the wallet file, or you had to restore the wallet to a backup from before they were spent.  Currently, the software just assumes it always knows whether its transactions are spent because it marks them spent in wallet.dat when it spends them. 
 
A wallet merge tool is possible to implement but much less in demand once resync solves most of the problem.  With resync, you could do about the same thing by sending all the money from one wallet to the other.  The receiver would resync and discover all its overlapping coins were spent, then receive them in the new transaction. 

That's the right way to do it as riX says.  The software can generate a new bitcoin address whenever you need one for each payment.  "Please send X bc to [single-use bitcoin address] to complete your order"  When the server receives that amount to the bitcoin address, that could trigger it to automatically fulfil the order or e-mail the shop owner. 
 
Adding command line support is a high priority.  It's just a matter of getting the time to code it. 

The recommended ways to do a payment for an order: 
1) The merchant has a static IP, the customer sends to it with a comment. 
2) The merchant creates a new bitcoin address, gives it to the customer, the customer sends to that address.  This will be the standard way for website software to do it. 
 
RSA vs ECDSA: it's not the size of the executable but the size of the data.  I thought it would be impractical if the block chain, bitcoin addresses, disk space and bandwidth requirements were all an order of magnitude bigger.  Also, even if using RSA for messages, it would still make sense to do all the bitcoin network with ECDSA and use RSA in parallel for only the message part.  In that case, everything that's been implemented up to now would be implemented exactly as it has been. 
 
We can figure out the best way to do this much later.  It could use a separate (maybe existing) e-mail or IM infrastructure to pass messages, and instead of RSA, maybe just put a hash of the message in the transaction to prove that the transaction is for the order described in the message.  The message would have to include a salt so nobody could brute force the hash to reveal a short message. 

I committed a fix for 64-bit compile and some fixes to support wxWidgets 2.9.0. 
 
There was one compile error in serialize.h with min(sizeof()) that I fixed for 64-bit.  The rest of the 64-bit compile errors I was getting were in wxWidgets 2.8.9, so I started working on supporting wxWidgets 2.9.0. 
 
wxWidgets 2.9.0 is UTF-8.  We've been using the ANSI version of wxWidgets 2.8.9 in anticipation of wxWidgets UTF-8 support. 
 
I compiled and ran on 64-bit Ubuntu 9.10 Karmic. 
 
I think the only bug left is where the status number is mashed up.  I'm not sure why, I have to suspect it's a UTF-8 thing, but no idea how that could happen.  Haven't looked into it. 
 
build-unix.txt is updated and two makefiles on SVN: 
makefile.unix.wx2.8 
makefile.unix.wx2.9 
 
Unfortunately there's still no debian package for either version of wxWidgets we use.  They only have the wchar ("unicode") version of wxWidgets 2.8, which is a disaster because wchar wxString doesn't convert to std::string.  We use either ANSI wxWidgets 2.8, or wxWidgets 2.9.  So you still have to get it and build it yourself. 

I uploaded this fix to the SVN.  It watches for spent coins and updates your wallet on load and also continuously as blocks come in.  I also put a better error message, but it should never hit it because it always finds spent coins ahead of time, unless you spent the same money at the same time on two computers at once. 
 
If you want to try it, PM or e-mail me your e-mail address where I can send it as an attachment and also what OS (win, linux 32-bit, linux 64-bit). 

Thanks for that.  Which version of Windows? 

Port forwarding forwards a port to one computer.  It tells the router which computer handles connections to that port.  So that's the computer receiving. 
 
If you didn't set up port forwarding, then incoming connections won't go to any computer, and attempts to send to that IP would just say it couldn't connect to the recipient and nothing is sent.  When sending by IP, you still send to a bitcoin address, but your computer connects to that IP, gets a new bitcoin address from it, gives the transaction directly to the them and confirms that it was received and accepted. 
 
Someone should post their static IP so people can try out sending by IP and also give that user free money. 
 
There's a 32-bit checksum in bitcoin addresses so you can't accidentally type an invalid address. 
 
If 4) you send to a recipient who has abandoned or lost their wallet.dat, then the money is lost.  A subtle point can be made that since there is then less total money in circulation, everyone's remaining money is worth slightly more, aka "natural deflation". 

When using proxy port 9050, it will only make one attempt to connect to IRC, then give up, since it knows it will probably always fail because IRC servers ban all the TOR exit nodes.  If you're using another port, it would assume it might be a regular old normal proxy and would keep retrying IRC at longer and longer intervals.  You should not use Polipo or Privoxy as those are http filters and caches that would corrupt Bitcoin's messages if they make any changes.  Bitcoin might be trying to overcome it by reconnecting.  You should use port 9050. 
 
As riX says, the "is giving Tor only an IP address. Apps that do DNS..." warnings are nothing to worry about.  Bitcoin doesn't use DNS at all in proxy mode. 
 
Since Bitcoin can't get through to IRC through Tor, it doesn't know which nodes are currently online, so it has to try all the recently seen nodes.  It tries to conserve connection attempts as much as possible, but also people want it to connect quickly when they start it up and reconnect quickly if disconnected.  It uses an algorithm where it tries an IP less and less frequently the longer ago it was successful connected.  For example, for a node it saw 24 hours ago, it would wait 5 hours between connection attempts.  Once it has at least 2 connections, it won't try anything over a week old, and 5 connections it won't try anything over 24 hours old. 

We had our first automatic adjustment of the proof-of-work difficulty on 30 Dec 2009.   
 
The minimum difficulty is 32 zero bits, so even if only one person was running a node, the difficulty doesn't get any easier than that.  For most of last year, we were hovering below the minimum.  On 30 Dec we broke above it and the algorithm adjusted to more difficulty.  It's been getting more difficult at each adjustment since then. 
 
The adjustment on 04 Feb took it up from 1.34 times last year's difficulty to 1.82 times more difficult than last year.  That means you generate only 55% as many coins for the same amount of work. 
 
The difficulty adjusts proportionally to the total effort across the network.  If the number of nodes doubles, the difficulty will also double, returning the total generated to the target rate. 
 
For those technically inclined, the proof-of-work difficulty can be seen by searching on "target:" in debug.log.  It's a 256-bit unsigned hex number, which the SHA-256 value has to be less than to successfully generate a block.  It gets adjusted every 2016 blocks, typically two weeks.  That's when it prints "GetNextWorkRequired RETARGET" in debug.log.  
 
minimum    00000000ffff0000000000000000000000000000000000000000000000000000 
30/12/2009 00000000d86a0000000000000000000000000000000000000000000000000000 
11/01/2010 00000000c4280000000000000000000000000000000000000000000000000000 
25/01/2010 00000000be710000000000000000000000000000000000000000000000000000 
04/02/2010 000000008cc30000000000000000000000000000000000000000000000000000 
14/02/2010 0000000065465700000000000000000000000000000000000000000000000000 
24/02/2010 0000000043b3e500000000000000000000000000000000000000000000000000 
08/03/2010 00000000387f6f00000000000000000000000000000000000000000000000000 
21/03/2010 0000000038137500000000000000000000000000000000000000000000000000 
01/04/2010 000000002a111500000000000000000000000000000000000000000000000000 
12/04/2010 0000000020bca700000000000000000000000000000000000000000000000000 
21/04/2010 0000000016546f00000000000000000000000000000000000000000000000000 
04/05/2010 0000000013ec5300000000000000000000000000000000000000000000000000 
19/05/2010 00000000159c2400000000000000000000000000000000000000000000000000 
29/05/2010 000000000f675c00000000000000000000000000000000000000000000000000 
11/06/2010 000000000eba6400000000000000000000000000000000000000000000000000 
24/06/2010 000000000d314200000000000000000000000000000000000000000000000000 
06/07/2010 000000000ae49300000000000000000000000000000000000000000000000000 
13/07/2010 0000000005a3f400000000000000000000000000000000000000000000000000 
16/07/2010 000000000168fd00000000000000000000000000000000000000000000000000 
27/07/2010 00000000010c5a00000000000000000000000000000000000000000000000000 
05/08/2010 0000000000ba1800000000000000000000000000000000000000000000000000 
15/08/2010 0000000000800e00000000000000000000000000000000000000000000000000 
26/08/2010 0000000000692000000000000000000000000000000000000000000000000000 
 
date, difficulty factor, % change 
2009           1.00 
30/12/2009     1.18   +18% 
11/01/2010     1.31   +11% 
25/01/2010     1.34    +2% 
04/02/2010     1.82   +36% 
14/02/2010     2.53   +39% 
24/02/2010     3.78   +49% 
08/03/2010     4.53   +20% 
21/03/2010     4.57    +9% 
01/04/2010     6.09   +33% 
12/04/2010     7.82   +28% 
21/04/2010    11.46   +47% 
04/05/2010    12.85   +12% 
19/05/2010    11.85    -8% 
29/05/2010    16.62   +40% 
11/06/2010    17.38    +5% 
24/06/2010    19.41   +12% 
06/07/2010    23.50   +21% 
13/07/2010    45.38   +93% 
16/07/2010   181.54  +300% 
27/07/2010   244.21   +35% 
05/08/2010   352.17   +44% 
15/08/2010   511.77   +45% 
26/08/2010   623.39   +22% 

That's not possible.  You've handed control of the money over to the recipient's keypair.  Only that key can control it. 
 
It's similar to if you encrypt a file with AES and a strong password, and you lose the password.  The data is lost. 

When you send to a bitcoin address, you don't connect to the recipient.  You send the transaction to the network the same way you relay transactions.  There's no distinction between a transaction you originated and one you received from another node that you're relaying in a broadcast.  With a very small network though, someone might still figure it out by process of elimination.  It'll be better when the network is larger. 
 
If you send by IP, the recipient sees you because you connect to their IP.  You could use TOR to mask that. 
 
You could use TOR if you don't want anyone to know you're even using Bitcoin. 
 
Bitcoin is still very new and has not been independently analysed.  If you're serious about privacy, TOR is an advisable precaution. 

Eventually at most only 21 million coins for 6.8 billion people in the world if it really gets huge. 
 
But don't worry, there are another 6 decimal places that aren't shown, for a total of 8 decimal places internally.  It shows 1.00 but internally it's 1.00000000.  If there's massive deflation in the future, the software could show more decimal places. 
 
If it gets tiresome working with small numbers, we could change where the display shows the decimal point.  Same amount of money, just different convention for where the ","'s and "."'s go.  e.g. moving the decimal place 3 places would mean if you had 1.00000 before, now it shows it as 1,000.00. 

No, sorry.  I've been meaning to redo it.  The largest icon that still looks good is the 20x20 one which is used for the tray icon in GNOME.  Any larger than that looks bad.  The 16x16 and 20x20 ones have quite a bit of hand tweaking to get the pixels to work out right.  If you just scale down a larger image, the pixels end up blurred and awkward in places where the lines in "BC" don't land square on a pixel. 
 
The best 16x16 with full alpha channel is in src/rc/bitcoin.ico.  I don't like the 32x32 version. 
 
I'm attaching bitcoin20x20.png, the 20x20 version with full transparency. 

Thank you for the offer to help translate.  That is probably the best way you could help. 
 
I will need to prepare the code for translation first.  wxWidgets has locale support, and most strings are in generated code that is already wrapped, so it shouldn't be too hard.  We also must finish upgrading to wxWidgets-2.9.0 to get UTF-8 support.  I've done test builds with 2.9.0 and there is one bug left to fix.  
 
What operating system are you using?  Windows, Linux 32-bit or 64 bit? 

It's much easier to have a single binary and multiple .mo files.  It's too much maintenance work to have lots of build variations.  Once the software support is implemented, anyone could contribute translations. 
 
wxWidgets uses the gettext standard.  You use the gettext tools or something like poedit to create a .po file by scanning the sourcefiles for strings and editing the translations into the .po file, then compile it into a .mo file.  The program loads the .mo file at runtime and reskins all the strings.  Additional languages can be added to an existing program by adding .mo files without recompiling the program. 
 
On Windows, the .mo files would go in a lang subdirectory in the directory where the EXE is located. 
 
Right now I'm working on JSON-RPC and command line support, but when I'm finished with that I hope to do this next. 

There are command line options: 
 
bitcoin -addnode=1.2.3.4    to tell bitcoin about a node to connect to 
bitcoin -connect=1.2.3.4    connect only to the specified node(s) 
 
You can use more than one of these, for instance 
bitcoin -connect=(first to try) -connect=(next to try) ... 
 
You can specify non-routable IPs with -connect like 192.168.x.x, so if you had a server farm and you wanted one server to connect to the world and the rest to connect to the one server, you could do that. 
 
In particular, -addnode is needed if you're always going to connect through TOR, since the IRC server blocks all the TOR exit nodes.  To connect through TOR, you could use: 
 
bitcoin -proxy=127.0.0.1:9050 -addnode=212.159.72.216 

Are you just trying to run the program or do you really need to compile it?  There's a 32-bit linux binary that can be run on 64-bit ubuntu if you "sudo apt-get ia32-libs". 
http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.2.0-linux.tar.gz/download 
 
I recently updated the SVN for building on 64-bit Karmic with wxWidgets 2.9.0.  This was after the 0.2.0 release.  The 0.2.0 release did not build on 64-bit yet. 
 
Unfortunately there currently isn't a -dev deb package of either of the versions of wxWidgets that we can use.  On Karmic they only have the UTF-16 version.  We need either the ANSI (libwxgtk2.8-ansi-dev) version or the UTF-8 (wxWidgets 2.9.0) version.  We're moving towards 2.9.0. 
 
I know you said you didn't want VM, but as a last resort, last I checked the Windows version runs fine in Wine. 

There's a small transaction fee for very large transactions.  The node that generates the block that contains the transaction gets the fee. 
 
If the same money gets sent again, it won't incur the fee again.  If all you have is generated coins in your wallet, if you send them all in one huge transaction, it has to bundle hundreds of 50 bc coins together.  After that it's just one line to send the combined unit. 

Am I missing something?  Is there something wrong with the 32-bit linux precompiled binary on bitcoin.org? 
 
The bitcoin binary in the distribution static links the wxWidgets library, and its shared links (openssl and GTK) are included in Ubuntu, so it can run without needing to be a .deb to pull down dependencies. 
 
Since we're upgrading to wxWidgets 2.9.0 for UTF-8, which doesn't have a DEB package yet, we'll continue to need to static link it. 

True, sending by IP through Tor trades one problem for another.  The Tor exit node can see the text of your message and potentially MITM you. 
 
Best to only send to bitcoin addresses then.  Payments by bitcoin address are broadcast over the network as part of the normal network traffic.  All communications with the network are broadcasts of public information. 

I couldn't get wxWidgets 2.8.9 to compile on Karmic 64-bit either. 
 
I have been compiling the latest SVN on Karmic 64-bit with wxWidgets 2.9.0, which compiles fine on 64-bit.  Read build-unix.txt and use the given ../configure parameters on wxWidgets so you can use the makefile.unix.wx2.9 as supplied.  (--enable-debug --disable-shared --enable-monolithic) 
 
There's one cosmetic bug with 2.9.0 I still need to fix where the status number display is bunched up for some reason.  -- fixed 
 
The download link on the homepage is to the sourceforge tar.gz archive which contains the 32-bit binary and the 0.2.0 sources, which were not yet buildable on 64-bit at the time. 
 
The SVN was first buildable on 64-bit with wx2.9.0 on 28 January 2010. 
 
Hopefully they'll have a wxWidgets 2.9.0 debian package someday. 

Yes. 

Almost all transactions are free.  A transaction is over the maximum size limit if it has to add up more than 500 of the largest payments you've received to make up the amount.  A transaction over the size limit can still be sent if a small fee is added. 
 
The average transaction, and anything up to 500 times bigger than average, is free. 
 
It's only when you're sending a really huge transaction that the transaction fee ever comes into play, and even then it only works out to something like 0.002% of the amount.  It's not money sucked out of the system, it just goes to other nodes.  If you're sad about paying the fee, you could always turn the tables and run a node yourself and maybe someday rake in a 0.44 fee yourself. 

Right.  Otherwise we couldn't have a finite limit of 21 million coins, because there would always need to be some minimum reward for generating.  In a few decades when the reward gets too small, the transaction fee will become the main compensation for nodes.  I'm sure that in 20 years there will either be very large transaction volume or no volume. 

Another big jump in difficulty yesterday from 1.82 times to 2.53 times, a 39% increase since 10 days ago.  It was 10 days apart not 14 because more nodes joined and generated the 2016 blocks in less time. 

Right now there isn't a port number setting to do that.  It's a feature yet to be implemented.  You can only set up your NAT to port-forward to one of the computers.  (I said something earlier about NAT port translation, but that wouldn't work, other nodes wouldn't know to connect to that port) 
 
If you want, as a small optimization, you could run the rest of your computers as: 

so they get all their network communication from the first computer and don't all connect over the net individually for the same information.  This saves bandwidth, although it doesn't use much bandwidth to begin with, so it wouldn't really matter unless you had tons of computers. 
 
For redundancy in case the first computer goes down, you could have two that connect out and the rest connect to both of them.  The first two are run normally, the rest are run like: 

I thought about that but there wasn't a practical way to do smaller increments.  The frequency of block generation is balanced between confirming transactions as fast as possible and the latency of the network. 
 
The algorithm aims for an average of 6 blocks per hour.  If it was 5 bc and 60 per hour, there would be 10 times as many blocks and the initial block download would take 10 times as long.  It wouldn't work anyway because that would be only 1 minute average between blocks, too close to the broadcast latency when the network gets larger. 

2 seconds of latency in both directions should reduce your generation success by less than 1%. 

Probably OK, but I'm not sure.  The protocol is designed to resync to the next message, and messages get re-requested from all the other nodes you're connected to until received.  If you miss a block, it'll also keep requesting it every time another blocks comes in and it sees there's a gap.  Before the original release I did a test dropping 1 out of 4 random messages under heavy load until I could run it overnight without any nodes getting stuck. 

I updated the SVN with changes to support translation.  Translatable strings are all enclosed in _(""), and we're using UTF-8 on all platforms. 
 
When the program runs, it looks in the directory of the EXE for the file: locale\<langcode>\LC_MESSAGES\bitcoin.mo 
 
<langcode> is the two letter code of the language your OS is set to, like "de" or "nl". 
 
On Linux, it also looks for: 
/usr/share/locale/<langcode>/LC_MESSAGES/bitcoin.mo 
/usr/local/share/locale/<langcode>/LC_MESSAGES/bitcoin.mo 
(are there other standard places it should look on linux?) 
 
Here's a quick walkthrough using poedit to make a .po and .mo file: 
 
- Download the bitcoin sourcecode from SVN 
- In the trunk directory, mkdir locale\<lang>\LC_MESSAGES 
- In poedit, File->New catalog->Paths tab 
- Click the "New item" dotted rectangle button 
- Put "../../.." and MAKE SURE TO PRESS ENTER to add the path 
- Click OK 
- Save the file as "bitcoin.po" in the LC_MESSAGES directory you made 
- It should then scan the sourcecode and find about 170 strings 
- If it didn't find anything, check Catalog->Settings->Path tab, make sure the "../../.." was added 
 
When you're done translating, commit both bitcoin.po (the editable catalog file) and bitcoin.mo (compiled data used by the program). 

Nodes stop trying to initiate connections once they have 15.  If you can accept incoming connections, then you can get well above that from nodes connecting to you, otherwise you max out at 15. 
 
I don't know if there's any reason to have 15 connections.  Maybe it should be 10. 
 
Since nodes that can only connect out are probably at or near 15 most of the time now, you should level off to an equilibrium.  45 suggests a ratio of 3 out-only nodes to every 1 in-accepting node. 
 
The number of connections won't be a good gauge of the size of the network any more.  Someone should periodically IRC to the bitcoin channel on chat.freenode.net and count the number of users.  That gives you the total count of network nodes (except TOR nodes). 
 
Block generation is again running ahead of pace.  We're in for another big step up in difficulty at the next adjustment in about 5 days. 

It would be nice to have a list of static IPs for new users to send test donations to so they can see how the software works.  If you can accept incoming connections and you have a static IP address, post it here! 
 
Anything sent to these IPs should be considered a donation.   
 
If you do request a round-trip, be sure to include your return bitcoin address or IP in the comment, but please assume it'll be one-way.  They won't necessarily be watching for incoming transactions to send back. 

Excellent analysis, xc. 
 
A rational market price for something that is expected to increase in value will already reflect the present value of the expected future increases.  In your head, you do a probability estimate balancing the odds that it keeps increasing. 
 
In the absence of a market to establish the price, NewLibertyStandard's estimate based on production cost is a good guess and a helpful service (thanks).  The price of any commodity tends to gravitate toward the production cost.  If the price is below cost, then production slows down.  If the price is above cost, profit can be made by generating and selling more.  At the same time, the increased production would increase the difficulty, pushing the cost of generating towards the price. 
 
In later years, when new coin generation is a small percentage of the existing supply, market price will dictate the cost of production more than the other way around. 
 
At the moment, generation effort is rapidly increasing, suggesting people are estimating the present value to be higher than the current cost of production. 

Uploaded some UI changes to SVN as version 0.2.5. 
 
Instead of View->Show Generated, we now have tabs: 
- All Transactions 
- Sent/Received 
- Sent 
- Received 
 
Makes it a lot easier to flip to received and check for payments. 
 
Moved the "Your Addresses" book inside the main address book.  It was confusing having two address books. 
 
I found the "To:" in "From: unknown, To: (one of your bitcoin addresses)" still confusing, so I changed it to "From: unknown, Received with:".  The bitcoin address is abbreviated so you can see the label that you set in the Receiving tab of the address book. 
 
Fixed a few UI glitches from the upgrade to wxWidgets 2.9.0. 
 
I haven't forgotten about you people who want non-UI, but I had to do some fun stuff before more build bashing. 

Just a random streak of bad luck.  It looks steady to me. 
 
Competition doesn't have an effect until the next automatic retarget adjustment, and we haven't reached the next one yet. 
 
The adjustments are every 2016 blocks.  To calculate our progress towards the next one, divide the block total by 2016.  The fractional part is how far we are to the next one.   
 
My back-of-the-envelope projection: 42032 blocks/2016 = 20.85 = 85% of the way.  About 1.5 days to go until the next one.  That'll only be about 10 days since the last one, the target is 14 days, so 14/10 = 1.4 = around 40% difficulty increase. 

There are now "Sending" and "Receiving" tabs in the Address Book.  Your addresses are referred to as "receiving addresses". 
 
madhatter was working on building it on Mac.  He had errors probably caused by UTF-16 wxWidgets 2.8.  Should have better luck now with 2.9.0.  wxWidgets 2.9.0 is UTF-8 and wouldn't have that problem. 
 
I think he had it working on FreeBSD, but he wanted a non-UI version. 
 
I have the command line and JSON-RPC daemon version working now.  Will SVN it in a day or two. 
 
I disabled gdm on my Ubuntu system so it boots into command line.  I hope I will be able to get it enabled again with rcconf. 

There's a separate public/private keypair for every bitcoin address.  You don't have a single private key that unlocks everything.  Bitcoin addresses are a 160-bit hash of the public key, everything else in the system is 256-bit. 
 
If there was a collision, the collider could spend any money sent to that address.  Just money sent to that address, not the whole wallet. 
 
If you were to intentionally try to make a collision, it would currently take 2^126 times longer to generate a colliding bitcoin address than to generate a block.  You could have got a lot more money by generating blocks. 
 
The random seed is very thorough.  On Windows, it uses all the performance monitor data that measures every bit of disk performance, network card metrics, cpu time, paging etc. since your computer started.  Linux has a built-in entropy collector.  Adding to that, every time you move your mouse inside the Bitcoin window you're generating entropy, and entropy is captured from the timing of disk ops. 

Ah yes, there we go, back to normal again. 
 
The ctrl+alt+F[1-8] thing never worked on this computer.  The screen just goes haywire. 

Version 0.2.6 on SVN can now run as a daemon and be controlled by command line or JSON-RPC. 
 
On Linux it needs libgtk2.0-0 installed, but does not need a GUI running.  Hopefully gtk can be installed without having a windowing system installed. 
 
The command to start as a daemon is: 
bitcoin -daemon [switches...] 
 
Or, to run the UI normally and also be able to control it from command line or JSON-RPC, use the "-server" switch. 
bitcoin -server [switches...] 
 
With either switch, it runs an HTTP JSON-RPC server that accepts local socket connections on 127.0.0.1:8332.  The port is bound to loopback and can only be accessed from the local machine, but from any account, not just the user it's running under. 
 
To control it from the command line, the interface is a command name without any switches, followed by parameters if any. 
bitcoin <command> [params...] 
 
For example: 
bitcoin getinfo 
bitcoin getdifficulty 
bitcoin setgenerate true 
bitcoin stop 
 
It's a simple JSON-RPC client and prints the JSON result.  Look at rpc.cpp for the list of commands. 
 
Web apps or anything automated will normally use JSON-RPC directly, not command line.  There are JSON-RPC libraries for all the major languages.  In script languages like PHP and Python the syntax is as natural as calling a local function. 

No, each generated transaction uses a new, single-use address. 
 
Nothing uses the address in the main window, it's just there for convenience for you to copy.  0.2.5 has a "New..." button next to it to make it easy to change each time you use it. 

That would be nice at point-of-sale.  The cash register displays a QR-code encoding a bitcoin address and amount on a screen and you photo it with your mobile. 

How much "dealing with" does GTK actually require?  Is it just a matter of "sudo apt-get install libgtk2.0-0" and having some extra libraries sitting around?  GTK doesn't have to do anything, just be there for bitcoin to link to when it loads up, have the gtk-init-check call fail because no GUI present, then it's done.   
 
It saves us butchering everything with ifdefs and a separate compile and binary to use wxBase just to try to avoid linking GTK. 

New icons, what do you think?  Better than the old one? 

Full size 530x529 image for scaling down to custom sizes: 
http://www.bitcoin.org/download/bitcoin530.png 
 
The perspective shadow was too thick on the larger sizes.  I updated 32, 48 and the full size. 
 
I release these images into the public domain (copyright-free).  I request that derivative works be made public domain. 

If you GPL stuff, I have to avoid using it.  Nothing against GPL per-se, but Bitcoin is an MIT license project.  Anything GPL please clearly mark it as such. 

When and how fast did memory usage increase?  Right away, slowly over a long time, or starting at some later event? 
 
I have -daemon running on ubuntu 9.10 64-bit and memory usage is steady. 
 
It has to be something about the difference on the server besides 64-bit.  Maybe some malfunction from the lack of GUI.  A memory leak debug tool could give a clue. 

The automatic adjustment happened earlier today. 
 
24/02/2010 0000000043b3e500000000000000000000000000000000000000000000000000 
 
24/02/2010  3.78  +49% 
 
I updated the first post. 

Yes, the original is 546x531 pixels. 
 
It looks good at larger size too, but since the small icons are what you mostly always see, I wanted to judge it on those first.  I'll post larger sizes and full size a little later. 

OK, I made a build target bitcoind that only links wxBase and does not link GTK.  Version 0.2.7 on SVN. 
 
I split out the init and shutdown stuff from ui.cpp into init.cpp, so now ui.cpp is pure UI.  ui.h provides inline stubs if wxUSE_GUI=0.  We only have four functions that interface from the node to the UI.  In the bitcoind build, we don't link ui.o or uibase.o. 

Sure feels like it could be something in wxWidgets retrying endlessly because some UI thing failed or something wasn't inited correctly.  Our hack to ignore the initialize failure and run anyway means we're in uncharted territory.  We're relying on the fact that we hardly use wx in this mode.  We do still use a few things like wxGetTranslation and wxMutex. 
 
Another way to debug would be to run in gdb, wait until everything is quiet and all threads should be idle, and break it and see which thread is busily doing something and what it's doing. 
 
I suspect bitcoind will probably work fine, but I hope you can still debug the problem. 

The formula is based on the time it takes to generate 2016 blocks.  The difficulty is multiplied by 14/(actual days taken).  For instance, this time it took 9.4 days, so the calculation was 14/9.4 = 1.49.  Previous difficulty 2.53 * 1.49 = 3.78, a 49% increase.  
 
I don't know what you're talking about accepting easier difficulties. 

wx/clipbrd.h isn't used, move it inside the #if wxUSE_GUI. 
 
Updated headers.h on SVN. 
 
Sorry, I linked to wxbase but I had full wxWidgets on my computer. 
 
The db.h:140 class Db no member named "exisits" is stranger.  pdb->get, pdb->put, pdb->del compiled before that.  Do you have version 4.7.25 of Berkeley DB? 
 
Db::exists() 
http://www.oracle.com/technology/documentation/berkeley-db/db/api_reference/CXX/frame_main.html 
http://www.oracle.com/technology/documentation/berkeley-db/db/api_reference/CXX/dbexists.html 
 
I suppose they might have added exists recently, using get before that. 

Good suggestion.  I made the B slightly lighter and the background slightly darker.  Very slightly.  The foreground is now exactly the same colour as the BC in the old one. 
 
It's kind of OK if you can't easily read the B in the 16x16.  At that size, you just need to see that it's a coin.  It doesn't matter so much what's embossed on it, just that there be some detail there because it wouldn't look like a coin if it was a blank smooth circle. 
 
It's slightly wider than tall because the dark perspective under it goes more to the right than down. 
 
I finished and posted the 32x31 and 48x47 versions in the first message.  I like the 48 a lot. 
 
How does everyone feel about the B symbol with the two lines through the outside?  Can we live with that as our logo? 

Are you using wxWidgets 2.9.0?  I don't recommend using anything other than 2.9.0. 
 
It looks like they've got a reference in the wx headers (arrstr.h) to something outside of wxBase. 
 
Removing -D__WXDEBUG__ from bitcoin's makefile would probably solve it. 
 
If that doesn't work and you just want to get it working, you could edit wxWidgets include/wx/arrstr.h, line 167 and comment out the wxASSERT_MSG. 

I don't know how to do SVG, but I did the original very large, over 500 pixels across, so it can be scaled down.  I'll give the original when I'm finished. 
 
I had to custom tweak each icon size so the vertical lines land square on their pixels, otherwise they're ugly blurry and inconsistent.  Such is the challenge of making icons.  The original will be good for scaling to custom sizes between 48 and 500 but not smaller. 

In the Windows world, "unicode" means UTF-16 (wchar). 
 
2.8 has two build variations, ANSI and UTF-16 (unicode).  The UTF-16 version is the "unicode" version provided in the Debian package.  I believe 2.8 and its UTF-16 build labelled simply "unicode" has been the source of build problems described in the forum.  We were previously using 2.8 ANSI in anticipation of getting to UTF-8 without going through UTF-16 hell.  We cannot compile with UTF-16. 
 
2.9 has only one version, UTF-8.  On Windows, we set the codepage to UTF-8, so on all platforms our code is UTF-8 and wxWidgets interfaces with us in UTF-8.  On Linux I assume the codepage is already UTF-8.  By standardizing on 2.9 we avoid the multi-build confusion of 2.8, and we need 2.9 for UTF-8 internationalization. 
 
Make sure you read build-unix.txt and configure wxWidgets using the configure parameters given. 
 
Curious, why is it incredibly hard to provide wxWidgets 2.9.0?  If you mean for users, that's why we static link it. 
 
It's unfortunate that we require so many big dependencies, but we need them all.  At least on Debian/Ubuntu, all but wxWidgets are available as packages.  Eventually they'll provide a 2.9 package. 

We have the standard icon sizes, and the full size scales nicely to anything else. 
 
I added the full size to the first post. 

When there's enough scale, maybe there can be an exchange site that doesn't do transfers, just matches up buyers and sellers to exchange with each other directly, similar to how e-bay works. 
 
To make it safer, the exchange site could act as an escrow for the bitcoin side of the payment.  The seller puts the bitcoin payment in escrow, and the buyer sends the conventional payment directly to the seller.  The exchange service doesn't handle any real world money. 
 
This would be a step better than e-bay.  E-bay manages to work fine even though shipped goods can't be recovered if payment falls through. 

sirius-m debugged this, it was 64-bit related.   
 
The fix is now available on SVN, file util.cpp. 

It sets different priorities for each thread.  The generate threads run at PRIO_MIN.  The other threads rarely take any CPU and run at normal. 
 
#define THREAD_PRIORITY_LOWEST          PRIO_MIN 
#define THREAD_PRIORITY_BELOW_NORMAL    2 
#define THREAD_PRIORITY_NORMAL          0 
 
The priorities converted from Windows priorities were probably from a table like this: 
 
   "The following table shows the mapping between nice values and Win32 priorities. Refer to the Win32 documentation for SetThreadPriority() for more information on Win32 priority issues. 
 
nice value    Win32 Priority 
-20 to -16    THREAD_PRIORITY_HIGHEST 
-15 to -6    THREAD_PRIORITY_ABOVE_NORMAL 
-5 to +4    THREAD_PRIORITY_NORMAL 
+5 to +14    THREAD_PRIORITY_BELOW_NORMAL 
+15 to +19    THREAD_PRIORITY_LOWEST" 
 
If you have better values, suggestions welcome. 
 
Also, there was some advice on the web that PRIO_PROCESS is used on Linux because threads are processes.  If that's not true, maybe it accounts for unexpectedly setting the priority of the whole app. 
 
    // threads are processes on linux, so PRIO_PROCESS affects just the one thread 
    setpriority(PRIO_PROCESS, getpid(), nPriority); 

When you want to upload an image to embed in a forum post, there are services like imageshack, but because they're free, they limit the number of views.  It's a minuscule amount of bandwidth cost, but they can't just give it away for free, there has to be something in it for them.  It would be nice to be able to pay for the bandwidth and avoid the limits, but conventional payments are too inconvenient for such a minor thing. 
 
It's worse if you want to upload a file for others to download.  There are services like rapidshare, but they require the downloaders to go through extra steps and delays to make them look at advertising or encourage upgrading to a paid subscription, and they limit it to 10 or so downloads. 
 
It would be nice if we made some free PHP code for an image and file hosting service that charges Bitcoins.  Anyone with some extra bandwidth quota could throw it on their webserver and run it.  Users could finally pay the minor fee to cover bandwidth cost and avoid the limits and hassles.  Ideally, it should be MIT license or public domain. 
 
Services like this would be great for anonymous users, who have trouble paying for things. 

Thanks soultcer for talking with the Freenode staffer.  Good to know it's OK at the current size, and now they know who we are.  They're supportive of projects like TOR so I hope they would probably be friendly to us.  We don't want to overstay our welcome.  If we get too big, then by the same token, we're big enough that we don't need IRC anymore and we'll get off. 
 
We only needed IRC because nobody had a static IP.  In the early days there were some steady supporters, but they all had pool-allocated IPs that change every few days.  IRC was only intended as a temporary solution.  Bitcoin's built-in addr system is the main solution. 
 
Bitcoin can get the list of IPs from any bitcoin node.  In that sense, every node serves as a directory server. 
 
When there are enough static IP nodes to have a good chance that at least one will still be running by the time the current version goes out of use, we can preprogram a seed list. 
 
How do you think we should compile the seed list?  Would it be OK to create it from the currently connected IPs that have been static for a while? 
 
BTW, if we want to supplement by deploying separate directory server software, may I suggest IRC?  IRC is a good directory server (I've heard it has other uses too), and there are mature IRC server implementations available that anyone can run. Bitcoin's IRC client implementation is already thoroughly tested. 

That's a great idea.  There's a thriving business in those services, but I've always thought the standard payment methods are at odds with privacy minded customers. 
 
Would you consider making your software freely available so anyone could easily set one up?  I know for competitive reasons the inclination is to keep it to yourself, but it could get an order of magnitude more use if anyone could give proxy access to their country just by putting the software on a server. 
 
I wonder if there are other kinds of web application servers where we would only have to tack on the payment mechanism to an already existing system? 

It's unrelated.  There wasn't anything there when I started. 
 
The price of .com registrations is lower than it should be, therefore any good name you might think of is always already taken by some domain name speculator.  Fortunately, it's standard for open source projects to be .org. 

LR and Pecunix have many established exchanges to paper currencies by various payment methods, and a number of vendors accept them as payment, so an exchange link between Bitcoin and LR/Pecunix would give us 2nd-hop access to all that.  The possibility to cash out through them would help support the value of bitcoins. 
 
Bitcoin has unique properties that would be complementary.  LR/Pecunix are easy to spend anonymously, but hard to buy anonymously and not worth the trouble to buy in small amounts.  Bitcoin, on the other hand, is easy to get in small amounts anonymously.  It would be convenient to buy LR/Pecunix with bitcoins rather than through conventional payment methods. 
 
Most customers who convert to LR to buy something would probably ask the seller first if they accept Bitcoin, encouraging them to start accepting it. 

Title changed. 
 
It helps that we have someone with actual experience running a proxy service.  Do you think Psiphon is the best one currently?  (sometimes the one you run was the best when you started but you found better ones later) 

Mihalism Multi Host is a popular open source PHP file hosting server. 
 
It's geared toward image hosting, but I think by increasing the file size limit and liberalising the allowed file extensions, it could just as easily be used for general file upload hosting.  They need the limits to keep it reasonable as a free service, but if we bolt on a Bitcoin payment mechanism, the limits could be relaxed. 
 
It doesn't have a bunch of client side scripting or anti-embedding junk to rip out.  It generates standard links that work normally. 
 
There's a turnover churn in these free hosting sites.  Small sites can give free image hosting, but once one starts getting popular, it gets too swamped with moochers using them for free bandwidth.  Any site that gets well known has to become more aggressively pay-naggy to cover bandwidth costs.  It's a perfect example of a service where the needed price point is in the no-man's-land between just a little too expensive to be free, but too cheap for most users to take the trouble of a conventional payment.  It's in the gap between 0 and 19.95.  The best they can do is try to maybe get 1 out of 1000 users to pay 9.95, but that has 999/1000 users treated like freeloaders.  It can't really be advertising supported because the images are embedded in other sites and downloaded without going to the hosting site. 
 
An example of a site running the software: 
http://www.imagez.ws/ 
 
Forum: 
http://www.mihalism.net/ 
 
Download: 
http://code.google.com/p/mihalismmh/ 
 
What do you think?  If I made a Bitcoin payment integration for this, would anyone be interested in running it?  It might be the first fully automated service available to buy with Bitcoins.  The advantage it could offer over the free services is general file upload hosting of large files without making downloading users go to the upload site and jump through hoops.  It would give a normal link directly to the file. 

When you generate a new bitcoin address, it only takes disk space on your own computer (like 500 bytes).  It's like generating a new PGP private key, but less CPU intensive because it's ECC.  The address space is effectively unlimited.  It doesn't hurt anyone, so generate all you want. 

That's a good idea.  At the very least a warning dialog explaining that it'll connect to the IP and send the information cleartext, giving the chance to cancel. 

There you go, we could easily do it the same way, like: 
http://127.0.0.1:8330/?to=<bitcoinaddress>;amount=<amount> 
 
Bitcoin can answer port 8330 on local loopback just as it does for JSON-RPC on 8332.  It would give an HTTP answer. 

I think we can do that. 
 
Although it would be possible for Bitcoin to take care of business in the HTTP response by presenting HTML UI to the user, as a user I would wonder if some website is trying to trick me or if I'm really talking to my own Bitcoin server. 
 
The HTTP response could simply be HTML with the JavaScript equivalent of the back button, sending it back to the page.  Bitcoin then pops up the Send Bitcoins dialog with the destination bitcoin address and amount already filled in.  It would work just like a mailto: link that pops up a new email with the address filled in. 
 
127.0.0.1 loopback is accessible by any user on the machine, it doesn't have per-user separation, but it's OK because it would only serve the convenience function of pre-filling the fields in a dialog.  You'd still have to press Send.  We'd have to make sure the Send button is not selected so it couldn't jump into the foreground while you're typing a space or enter. 

Does it happen every time you run it, or just happened once at some random time? 
 
I've never seen that fail before.  It's a call to OpenSSL that I assumed would never fail, but I put an error check there just in case.  I can't imagine how it would fail.  Out of memory maybe. 
 
The code is: 

key.h: 
    EC_KEY* pkey; 
 
        pkey = EC_KEY_new_by_curve_name(NID_secp256k1); 
        if (pkey == NULL) 
            throw key_error("CKey::CKey() : EC_KEY_new_by_curve_name failed"); 

 

NID_secp256k1 is a constant. 